package com.example.coinbasefix;

// *** ADDED MISSING IMPORT ***
import java.time.LocalDateTime;

import org.apache.commons.codec.binary.Base64;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import quickfix.ConfigError; // Keep this import

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;

// This class MUST be in its own file named CoinbaseAuthenticator.java
public class CoinbaseAuthenticator {

    private static final Logger log = LoggerFactory.getLogger(CoinbaseAuthenticator.class);
    private static final String HMAC_SHA256 = "HmacSHA256";
    // Coinbase requires ISO 8601 format with milliseconds and 'Z' for UTC in the prehash
    private static final DateTimeFormatter ISO_TIMESTAMP_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").withZone(ZoneOffset.UTC);
    // Formatter for parsing QuickFIX/J's default SendingTime format
    private static final DateTimeFormatter QFJ_TIMESTAMP_FORMAT = DateTimeFormatter.ofPattern("yyyyMMdd-HH:mm:ss.SSS");
    private static final char SOH = '\u0001'; // SOH character representation


    /**
     * Generates the prehash string required by Coinbase FIX authentication using SOH delimiters.
     * Format: timestamp + SOH + message_type + SOH + msg_seq_num + SOH + sender_comp_id + SOH + target_comp_id + SOH + password
     *
     * @param timestamp    SendingTime (Tag 52) raw value from QuickFIX/J message header.
     * @param messageType  MsgType (Tag 35)
     * @param msgSeqNum    MsgSeqNum (Tag 34)
     * @param senderCompId SenderCompID (Tag 49)
     * @param targetCompId TargetCompID (Tag 56)
     * @param password     Password/Passphrase (Tag 554)
     * @return The prehash string with SOH delimiters.
     * @throws ConfigError if the timestamp cannot be formatted correctly.
     */
    public static String createPrehash(String timestamp, String messageType, String msgSeqNum,
                                       String senderCompId, String targetCompId, String password)
            throws ConfigError { // Throw ConfigError for better signalling

        // Ensure timestamp is correctly formatted (ISO 8601 with millis and Z)
        String formattedTimestamp = formatTimestampForSigning(timestamp);
        if (formattedTimestamp == null) {
            // Critical error, cannot proceed with signing
            throw new ConfigError("Could not format timestamp for signing: " + timestamp);
        }

        // Construct prehash string with SOH delimiters
        // Ensure no null values are being appended unexpectedly (should be caught earlier)
        StringBuilder prehashBuilder = new StringBuilder();
        prehashBuilder.append(formattedTimestamp).append(SOH);
        prehashBuilder.append(messageType).append(SOH);
        prehashBuilder.append(msgSeqNum).append(SOH);
        prehashBuilder.append(senderCompId).append(SOH);
        prehashBuilder.append(targetCompId).append(SOH);
        prehashBuilder.append(password); // IMPORTANT: No SOH after the password

        String prehash = prehashBuilder.toString();

        // Debugging: Replace SOH with | for readability in logs ONLY
        log.debug("Prehash string for signing: {}", prehash.replace(SOH, '|'));

        return prehash;
    }

     /**
     * Parses QuickFIX/J's SendingTime format and reformats it to ISO 8601
      * with milliseconds and 'Z', as required for the Coinbase signature prehash.
     *
     * @param qfjSendingTimeValue Value from SendingTime (Tag 52), typically "yyyyMMdd-HH:mm:ss.SSS"
     * @return Formatted timestamp string "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", or null if parsing/formatting fails.
     */
     static String formatTimestampForSigning(String qfjSendingTimeValue) {
        if (qfjSendingTimeValue == null) {
            log.error("Received null timestamp for signing.");
            return null;
        }
        try {
            // Parse QuickFIX/J's typical format
            // *** USES LocalDateTime which needs import ***
            LocalDateTime ldt = LocalDateTime.parse(qfjSendingTimeValue, QFJ_TIMESTAMP_FORMAT);

            // Convert LocalDateTime (assuming it's UTC as generated by QFJ) to Instant
            Instant instant = ldt.toInstant(ZoneOffset.UTC);

            // Format the Instant into the required ISO format
            return ISO_TIMESTAMP_FORMAT.format(instant);

        } catch (DateTimeParseException e) {
            log.error("Failed to parse QFJ SendingTime string '{}' using format {}. Error: {}",
                      qfjSendingTimeValue, QFJ_TIMESTAMP_FORMAT.toString(), e.getMessage());
            // Attempt fallback parsing if needed, although QFJ format should be consistent
            return null; // Indicate failure
        } catch (Exception e) { // Catch any other unexpected errors during formatting
            log.error("Unexpected error formatting timestamp [{}]: {}", qfjSendingTimeValue, e.getMessage());
            return null; // Indicate failure
        }
    }


    /**
     * Signs the prehash string using HMAC-SHA256 with the provided Base64 encoded secret key.
     *
     * @param base64SecretKey The Base64 encoded API secret key.
     * @param prehash         The string to sign (should contain SOH delimiters).
     * @return The Base64 encoded signature.
     * @throws NoSuchAlgorithmException If HMAC-SHA256 algorithm is not available.
     * @throws InvalidKeyException    If the provided secret key is invalid.
     * @throws IllegalArgumentException If the base64SecretKey is null or empty.
     */
    public static String sign(String base64SecretKey, String prehash)
            throws NoSuchAlgorithmException, InvalidKeyException, IllegalArgumentException {

        if (base64SecretKey == null || base64SecretKey.trim().isEmpty()) {
             throw new IllegalArgumentException("API Secret Key cannot be null or empty for signing.");
        }
        if (prehash == null) {
             throw new IllegalArgumentException("Prehash string cannot be null for signing.");
        }

        byte[] secretKeyBytes = Base64.decodeBase64(base64SecretKey);
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKeyBytes, HMAC_SHA256);
        Mac mac = Mac.getInstance(HMAC_SHA256);
        mac.init(secretKeySpec);

        // Sign the prehash string (which now includes SOH chars)
        byte[] signatureBytes = mac.doFinal(prehash.getBytes(StandardCharsets.UTF_8));

        // Encode the resulting signature bytes to Base64
        String base64Signature = Base64.encodeBase64String(signatureBytes);
        log.debug("Generated Signature (Base64 RawData): {}", base64Signature);
        return base64Signature;
    }
}